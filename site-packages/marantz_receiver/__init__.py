"""
Marantz has an RS232 interface to control the receiver.

Not all receivers have all functions.
"""

import codecs
import socket
from time import sleep
from marantz_receiver.marantz_commands import CMDS
import serial
import threading
import telnetlib
import logging
import time

DEFAULT_TIMEOUT = 0.5
DEFAULT_WRITE_TIMEOUT = 0.5

_LOGGER = logging.getLogger(__name__)

class MarantzReceiver(object):
    """Marantz receiver."""

    def __init__(self, host, port, timeout=DEFAULT_TIMEOUT, write_timeout=DEFAULT_WRITE_TIMEOUT):
         """Create TCP/IP connection."""
         self.timeout = timeout
         self.host=host
         self.port=port
         self.lock = threading.Lock()
         self.connect()
        
    def connect(self):
        self.socket = socket.create_connection((self.host, self.port))
        self.socket.settimeout(self.timeout)

    def try_send(self, data, tries=3):
        try:
            self.socket.send(data)
            return True
        except Exception as e:
            if type(e) not in (BrokenPipeError, ConnectionResetError):
                _LOGGER.exception("Unknown exception type while sending") 
            # connection was lost, try to reconnect
            if tries:
                try:
                    self.connect()
                except:
                    time.sleep(1)
                    return self.try_send(data, tries-1)
            else:
                return False


    def exec_command(self, domain, function, operator, value=None):
        """
        Write a command to the receiver and read the value it returns.
        The receiver will always return a value, also when setting a value.
        """
        raw_command = CMDS[domain][function]['cmd']
        if operator in CMDS[domain][function]['supported_operators']:
            if value is None:
                raise ValueError('No value provided')
            else:
                cmd = ''.join([raw_command, operator, str(value)])

        else:
            raise ValueError('Invalid operator provided %s' % operator)
        with self.lock:
    
            # Marantz uses the prefix @ and the suffix \r, so add those to the above cmd.
            final_command = ''.join(['@', cmd, '\r']).encode('utf-8')
            _LOGGER.debug('Send Command %s', final_command)

            # send the command
            success = self.try_send(final_command)
            if not success:
                _LOGGER.warning("Failed to send data, could not connect to Marantz")
                return None

            # create an empty receive buffer
            buffer = ""

            # setup the timeout start
            start = time.time()

            # loop while we haven't timed out
            while time.time() - start < self.timeout:
                try:
                    buffer += self.socket.recv(2048).decode()
                except socket.timeout:
                    # let the loop check for the timeout
                    pass

                while True:
                    # split the buffer to get the first line
                    split_buffer = buffer.split('\r', 1)

                    # if we don't have a complete line in the buffer, read more bytes
                    if len(split_buffer)==1:
                        break

                    # get the line and put the rest back in the buffer
                    msg, buffer = split_buffer
                    _LOGGER.debug('Response msg %s', msg)

                    split_string = msg.strip().split(':')

                    _LOGGER.debug("Decoded split string %s", split_string)
                    _LOGGER.debug("Original command: %s", raw_command)
                    # Check return value contains the same command value as requested. Sometimes the marantz gets out of sync. Ignore if this is the case
                    if split_string[0] != ('@' + raw_command):
                        _LOGGER.debug("Send & Response command values don't match %s != %s - Ignoring returned value", split_string[0], '@' + raw_command )
                        break
                    else:
                        return split_string[1]
                        # b'AMT:0\r will return 0
            _LOGGER.debug("Read timed out")

        return None

    def main_mute(self, operator, value=None):
        """Execute Main.Mute."""
        return self.exec_command('main', 'mute', operator, value)

    def main_power(self, operator, value=None):
        """Execute Main.Power."""
        return self.exec_command('main', 'power', operator, value)

    def main_volume(self, operator, value=None):
        """
        Execute Main.Volume.
        Returns int
        """
        vol_result = self.exec_command('main', 'volume', operator, value)
        if vol_result != None:
            return int(vol_result)

    def main_source(self, operator, value=None):
        """Execute Main.Source."""
        result = self.exec_command('main', 'source', operator, value)
        """
        The receiver often returns the source value twice. If so take the
        second value as the source, otherwise return original
        """
        if result != None and len(result) == 2:
            _LOGGER.debug("Source Result: %s", result[1])
            return result[1]
        else:
            return result

    def main_sound_mode(self, operator, value=None):
        """Execute Main.SoundMode."""
        result_sound_mode = self.exec_command('main', 'sound_mode', operator, value)

        if result_sound_mode != None :
            return result_sound_mode

    def main_autostatus (self, operator, value=None):
        """
        Execute autostatus.
        Not currently used but will allow two-way communications in future

        Returns int
        """
        return int(self.exec_command('main', 'autostatus', operator, value))